#!/usr/bin/env bash
# =============================================================================
# tmux-path: Display current working directory with various styles
# Styles: minimal, short, full
# Usage: path --dir <path> --style <style> --depth <n>
# =============================================================================

# Shorten path by abbreviating each directory to first character
# Example: /Users/foo/bar/baz -> /U/f/b/baz
shorten_path() {
  local path="$1"
  local result=""
  local IFS='/'

  # Handle home directory
  if [[ "$path" == "$HOME"* ]]; then
    path="~${path#$HOME}"
  fi

  # Split path into components
  read -ra parts <<< "$path"

  local last_index=$((${#parts[@]} - 1))
    local i=0

    for part in "${parts[@]}"; do
      if [[ -z "$part" ]]; then
        # Leading slash
        result+="/"
      elif [[ $i -eq $last_index ]]; then
        # Keep last component full
        result+="$part"
      else
        # Abbreviate to first character
        if [[ "$part" == .* ]]; then
          # Keep dot for hidden directories (e.g., .config -> .c)
          result+="${part:0:2}/"
        else
          result+="${part:0:1}/"
        fi
      fi
      ((i++))
    done

    echo "$result"
  }

# Get minimal path (last N components)
# Example: /Users/foo/bar/baz with depth=2 -> bar/baz
get_minimal_path() {
  local path="$1"
  local depth="${2:-2}"

  # Handle home directory
  if [[ "$path" == "$HOME"* ]]; then
    path="~${path#$HOME}"
  fi

  # If path is just ~ or /, return as is
  if [[ "$path" == "~" ]] || [[ "$path" == "/" ]]; then
    echo "$path"
    return
  fi

  # Split and get last N components
  local IFS='/'
  read -ra parts <<< "$path"

  # Filter out empty parts (from leading slash)
  local filtered=()
  for part in "${parts[@]}"; do
    [[ -n "$part" ]] && filtered+=("$part")
  done

  local total=${#filtered[@]}

    if [[ $total -le $depth ]]; then
      echo "$path"
      return
    fi

    # Get last N components
    local start=$((total - depth))
    local result=""
    for ((i = start; i < total; i++)); do
      [[ -n "$result" ]] && result+="/"
      result+="${filtered[$i]}"
    done

    echo "$result"
  }

# Get full path with ~ for home
get_full_path() {
  local path="$1"

  if [[ "$path" == "$HOME"* ]]; then
    echo "~${path#$HOME}"
  else
    echo "$path"
  fi
}

# =============================================================================
# Main
# =============================================================================

show_usage() {
  cat << EOF
Usage: path [OPTIONS]

Display the current working directory with various formatting styles.

OPTIONS:
  --dir <path>      Directory path to display (default: \$PWD)
  --style <style>   Display style: minimal, short, full (default: minimal)
  --depth <n>       Number of directory levels for minimal style (default: 2)
  --help            Show this help message

STYLES:
  minimal           Display only last N directory levels (e.g., bar/baz)
  short             Abbreviate each directory to 1 character (e.g., ~/s/g/b/dotfiles)
  full              Display full path with ~ expansion (e.g., ~/src/github.com/babarot/dotfiles)

EXAMPLES:
  path --dir /Users/foo/bar/baz --style minimal --depth 2
  path --style short
  path --dir \$HOME/src --style full
EOF
}

main() {
  local cwd="$PWD"
  local style="minimal"
  local depth="2"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dir)
        if [[ -z "$2" || "$2" == --* ]]; then
          echo "Error: --dir requires a value" >&2
          exit 1
        fi
        cwd="$2"
        shift 2
        ;;
      --style)
        if [[ -z "$2" || "$2" == --* ]]; then
          echo "Error: --style requires a value" >&2
          exit 1
        fi
        style="$2"
        shift 2
        ;;
      --depth)
        if [[ -z "$2" || "$2" == --* ]]; then
          echo "Error: --depth requires a value" >&2
          exit 1
        fi
        depth="$2"
        shift 2
        ;;
      --help|-h)
        show_usage
        exit 0
        ;;
      *)
        echo "Error: Unknown option: $1" >&2
        show_usage
        exit 1
        ;;
    esac
  done

  case "$style" in
    "fullpath"|"full")
      get_full_path "$cwd"
      ;;
    "shortpath"|"short")
      shorten_path "$cwd"
      ;;
    "minimal"|*)
      get_minimal_path "$cwd" "$depth"
      ;;
  esac
}

main "$@"
