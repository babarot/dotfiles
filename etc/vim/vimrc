"      ___                       ___           ___           ___      
"     /\__\          ___        /\__\         /\  \         /\  \     
"    /:/  /         /\  \      /::|  |       /::\  \       /::\  \    
"   /:/  /          \:\  \    /:|:|  |      /:/\:\  \     /:/\:\  \   
"  /:/__/  ___      /::\__\  /:/|:|__|__   /::\~\:\  \   /:/  \:\  \  
"  |:|  | /\__\  __/:/\/__/ /:/ |::::\__\ /:/\:\ \:\__\ /:/__/ \:\__\ 
"  |:|  |/:/  / /\/:/  /    \/__/~~/:/  / \/_|::\/:/  / \:\  \  \/__/ 
"  |:|__/:/  /  \::/__/           /:/  /     |:|::/  /   \:\  \       
"   \::::/__/    \:\__\          /:/  /      |:|\/__/     \:\  \      
"    ~~~~         \/__/         /:/  /       |:|  |        \:\__\     
"                               \/__/         \|__|         \/__/     

" README:
" Copyright (c) 2013-2015 b4b4r07 (aka BABAROT) All Rights Reserved
" Thank you.
"==============================================================================

" Startup: {{{1
" Skip initialization for vim-tiny or vim-small
" take account of '-eval'
"if !1 | finish | endif
if 0 | endif

" Use plain vim
" when vim was invoked by 'sudo' command
" or, invoked as 'git difftool'
if exists('$SUDO_USER') || exists('$GIT_DIR')
  finish
endif

" Script variables {{{2
" boolean
let s:true  = 1
let s:false = 0

" platform
let s:is_windows = has('win16') || has('win32') || has('win64')
let s:is_cygwin = has('win32unix')
let s:is_mac = !s:is_windows && !s:is_cygwin
      \ && (has('mac') || has('macunix') || has('gui_macvim') ||
      \    (!executable('xdg-open') &&
      \    system('uname') =~? '^darwin'))
let s:is_linux = !s:is_mac && has('unix')

let s:vimrc = expand("<sfile>:p")
let $MYVIMRC = s:vimrc

" NeoBundle path
if s:is_windows
  let $DOTVIM = expand('~/vimfiles')
else
  let $DOTVIM = expand('~/.vim')
endif
let $VIMBUNDLE = $DOTVIM . '/bundle'
let $NEOBUNDLEPATH = $VIMBUNDLE . '/neobundle.vim'

" vimrc management variables
let s:vimrc_plugin_on                  = get(g:, 'vimrc_plugin_on',                  s:true)
let s:vimrc_suggest_neobundleinit      = get(g:, 'vimrc_suggest_neobundleinit',      s:true)
let s:vimrc_goback_to_eof2bof          = get(g:, 'vimrc_goback_to_eof2bof',          s:false)
let s:vimrc_save_window_position       = get(g:, 'vimrc_save_window_position',       s:false)
let s:vimrc_restore_cursor_position    = get(g:, 'vimrc_restore_cursor_position',    s:true)
let s:vimrc_statusline_manually        = get(g:, 'vimrc_statusline_manually',        s:true)
let s:vimrc_add_execute_perm           = get(g:, 'vimrc_add_execute_perm',           s:false)
let s:vimrc_colorize_statusline_insert = get(g:, 'vimrc_colorize_statusline_insert', s:true)
let s:vimrc_manage_rtp_manually        = get(g:, 's:vimrc_manage_rtp_manually',      s:false)
let s:vimrc_auto_cd_file_parentdir     = get(g:, 's:vimrc_auto_cd_file_parentdir',   s:true)
let s:vimrc_ignore_all_settings        = get(g:, 's:vimrc_ignore_all_settings',      s:false)

" if s:vimrc_manage_rtp_manually is s:true, s:vimrc_plugin_on is disabled.
let s:vimrc_plugin_on = s:vimrc_manage_rtp_manually == s:true ? s:false : s:vimrc_plugin_on

function! s:vimrc_environment()
  let env = {}

  let env.is_starting = has('vim_starting')
  let env.is_gui = has('gui_running')
  let env.hostname = substitute(hostname(), '[^\w.]', '', '')

  if s:is_windows
    let vimpath = expand('~/vimfiles')
  else
    let vimpath = expand('~/.vim')
  endif
  let vimbundle = vimpath . '/bundle'
  let neobundlepath = vimbundle . '/neobundle.vim'

  let env.path = {
    \ 'vim':       vimpath,
    \ 'bundle':    vimbundle,
    \ 'neobundle': neobundlepath,
  \ }

  let env.support = {
    \ 'ag':        executable('ag'),
    \ 'osascript': executable('osascript'),
  \ }

  let env.is_tabpage = (&showtabline == 1 && tabpagenr('$') >= 2)
              \ || (&showtabline == 2 && tabpagenr('$') >= 1)

  let env.is_neobundle = isdirectory($NEOBUNDLEPATH)

  return env
endfunction

" s:env is an environment variable in vimrc
let s:env = s:vimrc_environment()

" Startup time {{{2
if s:env.is_starting
  " Necesary for lots of cool vim things
  "set nocompatible
  scriptencoding utf-8
  set runtimepath&

  " Vim starting time
  if has('reltime')
    let g:startuptime = reltime()
    augroup vimrc-startuptime
      autocmd! VimEnter * let g:startuptime = reltime(g:startuptime) | redraw
            \ | echomsg 'startuptime: ' . reltimestr(g:startuptime)
    augroup END
  endif
endif

" Depelopment for Vim plugin {{{2
if len(findfile("Vimpfile", ".;")) > 0
  let s:vimrc_plugin_on = s:false
  set runtimepath&
  execute "set runtimepath+=" . s:cwd
  execute "set runtimepath+=" . s:cwd . "/.vimp"
  for s:plugin in split(glob(s:cwd . "/.vimp/*"), '\n')
    execute 'set runtimepath+=' . s:plugin
  endfor
endif

" NeoBundle: {{{1
" Next generation Vim package manager settings.
" Use the NeoBundle (if installed and found on the default search runtimepath).
" If it is not installed, suggest executing ':NeoBundleInit' command.
" The ':NeoBundleInit' allows us to initialize all about NeoBundle.
" TODO: 
"   - neobundle#tap
"   - TOML
"   - NeoBundleInit TEST
"==============================================================================

" Add neobundle to runtimepath.
if s:env.is_starting && s:env.is_neobundle
  if s:vimrc_plugin_on == s:true
            \ || v:progname ==# 'vi'
            \ || ! exists('v:version') || v:version < 702
            \ || ! executable('git')
    set runtimepath+=$NEOBUNDLEPATH
  endif
endif

" neobundle {{{
if stridx(&runtimepath, $NEOBUNDLEPATH) != -1
  let g:neobundle#enable_tail_path = 1
  let g:neobundle#default_options = {
        \ 'same' : { 'stay_same' : 1, 'overwrite' : 0 },
        \ '_' : { 'overwrite' : 0 },
        \ }
  "call neobundle#rc($VIMBUNDLE)
  call neobundle#begin($VIMBUNDLE)

  " Taking care of NeoBundle by itself
  NeoBundleFetch 'Shougo/neobundle.vim'

  " NeoBundle List
  "NeoBundle 'Shougo/unite.vim'
  NeoBundle 'Shougo/vimproc'

  if has('lua') && v:version >= 703
    NeoBundleLazy 'Shougo/neocomplete.vim'
  else
    NeoBundleLazy 'Shougo/neocomplcache.vim'
  endif

  "NeoBundle 'Shougo/unite-outline'
  "NeoBundle 'Shougo/unite-help'
  "NeoBundle 'Shougo/neomru.vim'
  "NeoBundle 'Shougo/vimfiler'
  "NeoBundle 'Shougo/vimshell'
  "NeoBundle 'Shougo/neosnippet'
  "NeoBundle 'Shougo/neosnippet-snippets'
  "NeoBundle 'glidenote/memolist.vim'
  "NeoBundle 'severin-lemaignan/vim-minimap'
  "NeoBundle 'thinca/vim-scouter'
  "NeoBundle 'thinca/vim-ref'
  "NeoBundle 'thinca/vim-quickrun'
  "NeoBundle 'thinca/vim-unite-history'
  "NeoBundle 'thinca/vim-splash'
  "NeoBundle 'thinca/vim-portal'
  "NeoBundle 'thinca/vim-poslist'
  "NeoBundle 'thinca/vim-tabrecent'
  "NeoBundle 'thinca/vim-qfreplace'
  "NeoBundle 'tyru/nextfile.vim'
  "NeoBundle 'tyru/skk.vim'
  "NeoBundle 'tyru/eskk.vim'
  "NeoBundle 'tyru/open-browser.vim'
  "NeoBundle 'tyru/restart.vim'
  "NeoBundle 'sjl/gundo.vim'
  NeoBundle 'ujihisa/neco-look'
  "NeoBundle 'ujihisa/unite-colorscheme'
  "NeoBundle 'b4b4r07/vim-vimp'
  "NeoBundle 'b4b4r07/vim-autocdls'
  "NeoBundle 'b4b4r07/mru.vim'
  NeoBundle 'b4b4r07/vim-shellutils'
  "NeoBundle 'b4b4r07/vim-favdir'
  "NeoBundle 'b4b4r07/vim-ezoe'
  "NeoBundle 'b4b4r07/vim-sunset'
  "NeoBundle 'b4b4r07/vim-pt'
  NeoBundle has('gui_running') ? 'itchyny/lightline.vim' : 'b4b4r07/vim-buftabs'
  "NeoBundle 'b4b4r07/vim-buftabs'
  "NeoBundle 'itchyny/calendar.vim'
  "NeoBundle 'nathanaelkane/vim-indent-guides'
  NeoBundle 'scrooloose/syntastic'
  "NeoBundle 'scrooloose/nerdtree'
  NeoBundle 'tpope/vim-surround'
  NeoBundle 'tpope/vim-repeat'
  NeoBundle 'tpope/vim-markdown'
  "NeoBundle 'tpope/vim-fugitive'
  "NeoBundle 'osyo-manga/vim-anzu'
  NeoBundle 'cohama/lexima.vim'
  "NeoBundle 'cohama/vim-insert-linenr'
  "NeoBundle 'cohama/agit.vim'
  "NeoBundle 'LeafCage/yankround.vim'
  "NeoBundle 'LeafCage/foldCC.vim'
  "NeoBundle 'junegunn/vim-easy-align'
  "NeoBundle 'mattn/gist-vim'
  "NeoBundle 'mattn/webapi-vim'
  "NeoBundle 'mattn/benchvimrc-vim'
  "NeoBundle 'vim-scripts/Align'
  "NeoBundle 'vim-scripts/DirDiff.vim'
  "NeoBundle 'mattn/excitetranslate-vim'
  "NeoBundle 'yomi322/unite-tweetvim'
  "NeoBundle 'tsukkee/lingr-vim'
  "NeoBundle 'AndrewRadev/switch.vim'
  "NeoBundle 'Yggdroot/indentLine'
  "NeoBundle 'ervandew/supertab'
  "NeoBundle 'vim-scripts/renamer.vim'
  "NeoBundle 'rking/ag.vim'
  "NeoBundle 'mopp/googlesuggest-source.vim'
  "NeoBundle 'mattn/googlesuggest-complete-vim'
  "NeoBundle 'kana/vim-vspec'
  "NeoBundle 'tell-k/vim-browsereload-mac'
  "NeoBundle 'junegunn/vim-emoji'
  "NeoBundle 'majutsushi/tagbar'
  "NeoBundle 'dgryski/vim-godef'
  "NeoBundle 'vim-jp/vim-go-extra'
  "NeoBundle 'google/vim-ft-go'
  "NeoBundle 'ctrlpvim/ctrlp.vim'
  "NeoBundle 'toyamarinyon/hatenablog-vim'
  NeoBundle 'justinmk/vim-dirvish'
  "NeoBundle 'deris/vim-visualinc'
  "NeoBundle 'hotchpotch/perldoc-vim'
  "NeoBundle 'kchmck/vim-coffee-script'
  NeoBundle 'elzr/vim-json'
  NeoBundle 'cespare/vim-toml'
  NeoBundle 'fatih/vim-go'
  NeoBundle 'jnwhiteh/vim-golang'
  NeoBundle 'zaiste/tmux.vim'
  "NeoBundle 'CORDEA/vim-glue'
  NeoBundle 'dag/vim-fish'
  "NeoBundle 'haya14busa/incsearch.vim'
  "NeoBundle 'rhysd/try-colorscheme.vim'
  "NeoBundle 'rhysd/github-complete.vim'
  "NeoBundle 'junegunn/fzf'
  NeoBundle 'vim-scripts/applescript.vim'


  " Japanese help
  NeoBundle 'vim-jp/vimdoc-ja'
  " Vital
  "NeoBundle 'vim-jp/vital.vim'

  " Colorschemes
  NeoBundle 'b4b4r07/solarized.vim', { "base" : $HOME."/.vim/colors" }
  "NeoBundle 'nanotech/jellybeans.vim', { "base" : $HOME."/.vim/colors" }
  "NeoBundle 'tomasr/molokai', { "base" : $HOME."/.vim/colors" }
  "NeoBundle 'w0ng/vim-hybrid', { "base" : $HOME."/.vim/colors" }

  " Disable plugins
  if !has('gui_running')
    "NeoBundleDisable lightline.vim
  endif
  "NeoBundleDisable mru.vim
  "NeoBundleDisable vim-buftabs

  " Manually manage rtp
  "NeoBundle 'vim-mru', {'type' : 'nosync', 'base' : '~/.vim/manual'}
  "NeoBundle 'vim-curbuf', {'type' : 'nosync', 'base' : '~/src/github.com/b4b4r07'}

  call neobundle#end()

  " Check.
  NeoBundleCheck
else
  " no neobundle {{{2
  command! NeoBundleInit try | call <SID>neobundle_init()
        \| catch /^neobundleinit:/
        \|   echohl ErrorMsg
        \|   echomsg v:exception
        \|   echohl None
        \| endtry

  function! s:neobundle_init()
    redraw
    echo "Installing neobundle.vim..."
    if !isdirectory($VIMBUNDLE)
      silent! call mkdir($VIMBUNDLE, 'p')
      echo printf("Creating '%s'.", $VIMBUNDLE)
    endif
    cd $VIMBUNDLE

    call system('git clone git://github.com/Shougo/neobundle.vim')
    if v:shell_error
      echoerr "neobundle.vim installation has failed!"
      finish
    endif

    set runtimepath& runtimepath+=$NEOBUNDLEPATH
    call neobundle#rc($VIMBUNDLE)
    echo printf("Reloading '%s'", $MYVIMRC)
    source $MYVIMRC

    echomsg 'Finish!'
  endfunction

  if s:vimrc_suggest_neobundleinit == s:true
    autocmd! VimEnter * redraw
          \ | echohl WarningMsg
          \ | echo "You should do ':NeoBundleInit' at first!"
          \ | echohl None
  else
    NeoBundleInit
  endif
endif
"}}}

" nessesary
filetype plugin indent on

" Library: in vimrc {{{1
" Functions that are described in this section is general functions.
" It is not general, for example, functions used in a dedicated purpose
" has been described in the setting position.
"==============================================================================

function! s:bundled(bundle) "{{{2
  if !isdirectory($VIMBUNDLE)
    return s:false
  endif
  if stridx(&runtimepath, $NEOBUNDLEPATH) == -1
    return s:false
  endif

  if a:bundle ==# 'neobundle.vim'
    return s:true
  else
    return neobundle#is_installed(a:bundle)
  endif
endfunction

function! s:has_plugin(name) "{{{2
  " Check {name} plugin whether there is in the runtime path
  let nosuffix = a:name =~? '\.vim$' ? a:name[:-5] : a:name
  let suffix   = a:name =~? '\.vim$' ? a:name      : a:name . '.vim'
  return &rtp =~# '\c\<' . nosuffix . '\>'
        \   || globpath(&rtp, suffix, 1) != ''
        \   || globpath(&rtp, nosuffix, 1) != ''
        \   || globpath(&rtp, 'autoload/' . suffix, 1) != ''
        \   || globpath(&rtp, 'autoload/' . tolower(suffix), 1) != ''
endfunction

function! s:startup_logo() "{{{2
  hide enew
  setlocal buftype=nofile nowrap nolist nonumber bufhidden=wipe
  setlocal modifiable nocursorline nocursorcolumn

  let b4b4r07 = []
  call add(b4b4r07, 'Copyright (c) 2014                                 b4b4r07''s vimrc.')
  call add(b4b4r07, '.______    _  _    .______    _  _    .______        ___    ______  ')
  call add(b4b4r07, '|   _  \  | || |   |   _  \  | || |   |   _  \      / _ \  |____  | ')
  call add(b4b4r07, '|  |_)  | | || |_  |  |_)  | | || |_  |  |_)  |    | | | |     / /  ')
  call add(b4b4r07, '|   _  <  |__   _| |   _  <  |__   _| |      /     | | | |    / /   ')
  call add(b4b4r07, '|  |_)  |    | |   |  |_)  |    | |   |  |\  \----.| |_| |   / /    ')
  call add(b4b4r07, '|______/     |_|   |______/     |_|   | _| `._____| \___/   /_/     ')
  call add(b4b4r07, 'If it is being displayed, the vim plugins are not set and installed.')
  call add(b4b4r07, 'In this environment, run '':NeoBundleInit'' if you setup vim plugin.')

  silent put =repeat([''], winheight(0)/2 - len(b4b4r07)/2)
  let space = repeat(' ', winwidth(0)/2 - strlen(b4b4r07[0])/2)
  for line in b4b4r07
    put =space . line
  endfor
  silent put =repeat([''], winheight(0)/2 - len(b4b4r07)/2 + 1)
  silent file B4B4R07
  1

  execute 'syntax match Directory display ' . '"'. '^\s\+\U\+$'. '"'
  setlocal nomodifiable
  redraw
  let char = getchar()
  silent enew
  call feedkeys(type(char) == type(0) ? nr2char(char) : char)
endfunction

function! s:echomsg(hl, msg) "{{{2
  execute 'echohl' a:hl
  try
    echomsg a:msg
  finally
    echohl None
  endtry
endfunction

function! s:error(msg) "{{{2
  call <SID>echomsg("ErrorMsg", "ERROR: " . a:msg)
  return s:false
endfunction

function! s:warning(msg) "{{{2
  call <SID>echomsg("WarningMsg", "ERROR: " . a:msg)
  return s:false
endfunction

function! s:mkdir(dir) "{{{2
  if !exists("*mkdir")
    return s:false
  endif

  let dir = expand(a:dir)
  if isdirectory(dir)
    return s:true
  endif

  return mkdir(dir, "p")
endfunction

function! s:auto_mkdir(dir, force) "{{{2
  if !isdirectory(a:dir) && (a:force ||
        \ input(printf('"%s" does not exist. Create? [y/N] ', a:dir)) =~? '^y\%[es]$')
    call s:mkdir(iconv(a:dir, &encoding, &termencoding))
  endif
endfunction

function! s:smart_foldcloser() "{{{2
  if foldlevel('.') == 0
    normal! zM
    return
  endif

  let foldc_lnum = foldclosed('.')
  normal! zc
  if foldc_lnum == -1
    return
  endif

  if foldclosed('.') != foldc_lnum
    return
  endif
  normal! zM
endfunction

function! s:rand(n) "{{{2
  let match_end = matchend(reltimestr(reltime()), '\d\+\.') + 1
  return reltimestr(reltime())[match_end : ] % (a:n + 1)
endfunction

function! s:random_string(n) "{{{2
  let n = a:n ==# '' ? 8 : a:n
  let s = []
  let chars = split('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', '\ze')
  let max = len(chars) - 1
  for x in range(n)
    call add(s, (chars[s:rand(max)]))
  endfor
  let @+ = join(s, '')
  return join(s, '')
endfunction

function! s:toggle_option(option_name) "{{{2
  if exists('&' . a:option_name)
    execute 'setlocal' a:option_name . '!'
    execute 'setlocal' a:option_name . '?'
  endif
endfunction

function! s:rename(new, type) "{{{2
  if a:type ==# 'file'
    if empty(a:new)
      let new = input('New filename: ', expand('%:p:h') . '/', 'file')
    else
      let new = a:new
    endif
  elseif a:type ==# 'ext'
    if empty(a:new)
      let ext = input('New extention: ', '', 'filetype')
      let new = expand('%:p:t:r')
      if !empty(ext)
        let new .= '.' . ext
      endif
    else
      let new = expand('%:p:t:r') . '.' . a:new
    endif
  endif

  if filereadable(new)
    redraw
    echo printf("overwrite `%s'? ", new)
    if nr2char(getchar()) ==? 'y'
      silent call delete(new)
    else
      return s:false
    endif
  endif

  if new != '' && new !=# 'file'
    let oldpwd = getcwd()
    lcd %:p:h
    execute 'file' new
    execute 'setlocal filetype=' . fnamemodify(new, ':e')
    write
    call delete(expand('#'))
    execute 'lcd' oldpwd
  endif
endfunction

function! s:make_junkfile() "{{{2
  let junk_dir = $HOME . '/.vim/junk'. strftime('/%Y/%m/%d')
  if !isdirectory(junk_dir)
    call s:mkdir(junk_dir)
  endif

  let ext = input('Junk Ext: ')
  let filename = junk_dir . tolower(strftime('/%A')) . strftime('_%H%M%S')
  if !empty(ext)
    let filename = filename . '.' . ext
  endif
  execute 'edit ' . filename
endfunction

function! s:copy_current_path(...) "{{{2
  let path = a:0 ? expand('%:p:h') : expand('%:p')
  if s:is_windows
    let @* = substitute(path, '\\/', '\\', 'g')
  else
    let @* = path
  endif
  echo path
endfunction

function! s:load_source(path) "{{{2
  let path = expand(a:path)
  if filereadable(path)
    execute 'source ' . path
  endif
endfunction

function! s:open(file) "{{{2
  if !s:is_mac
    call s:error('mac only')
    return 1
  endif

  if !executable('open')
    return s:error('open: not supported yet.')
  endif

  let file = empty(a:file) ? expand('%') : fnamemodify(a:file, ':p')
  call system(printf('%s %s &', 'open', shellescape(file)))
  return v:shell_error ? s:false : s:true
endfunction

function! s:rm(...) "{{{2
  let files = []
  for file in a:0 ? map(copy(a:000), 'expand(v:val)') : split(simplify(expand('%:p')))

    let file = fnamemodify(file, ":p")
    if isdirectory(file)
      let dest = "/tmp/".s:random_string(20)
      if rename(file, dest) == 0
        call add(files, file)
      else
        call s:error("not support a directory")
      endif
    elseif filereadable(file)
      if delete(file) == 0
        call add(files, file)
        let bufname = bufname(fnamemodify(file, ':p'))
        if bufexists(bufname) && buflisted(bufname)
          execute "bwipeout" bufname
        endif
      endif
    else
      echohl WarningMsg | echo "The '" . file . "' does not exist" | echohl NONE
    endif
  endfor

  echo len(files) ? "Removed " . string(files) . "!" : "Removed nothing"
endfunction

function! s:ls(path, bang) "{{{2
  let path = empty(a:path) ? getcwd() : expand(a:path)
  if filereadable(path)
    if executable("ls")
      echo system("ls -l " . path)
      return v:shell_error ? s:false : s:true
    else
      return s:error('ls: command not found')
    endif
  endif

  if !isdirectory(path)
    return s:error(path.":No such file or directory")
  endif

  let save_ignore = &wildignore
  set wildignore=
  let filelist = glob(path . "/*")
  if !empty(a:bang)
    let filelist .= "\n".glob(path . "/.*[^.]")
  endif
  let &wildignore = save_ignore
  let filelist = substitute(filelist, '', '^M', 'g')

  if empty(filelist)
    return s:error("no file")
  endif

  let lists = []
  for file in split(filelist, "\n")
    if isdirectory(file)
      call add(lists, fnamemodify(file, ":t") . "/")
    else
      if executable(file)
        call add(lists, fnamemodify(file, ":t") . "*")
      elseif getftype(file) == 'link'
        call add(lists, fnamemodify(file, ":t") . "@")
      else
        call add(lists, fnamemodify(file, ":t"))
      endif
    endif
  endfor

  echohl WarningMsg | echon len(lists) . ":\t" | echohl None
  highlight LsDirectory  cterm=bold ctermfg=NONE ctermfg=26        gui=bold guifg=#0096FF   guibg=NONE
  highlight LsExecutable cterm=NONE ctermfg=NONE ctermfg=Green     gui=NONE guifg=Green     guibg=NONE
  highlight LsSymbolick  cterm=NONE ctermfg=NONE ctermfg=LightBlue gui=NONE guifg=LightBlue guibg=NONE

  for item in lists
    if item =~ '/'
      echohl LsDirectory | echon item[:-2] | echohl NONE
      echon item[-1:-1] . " "
    elseif item =~ '*'
      echohl LsExecutable | echon item[:-2] | echohl NONE
      echon item[-1:-1] . " "
    elseif item =~ '@'
      echohl LsSymbolick | echon item[:-2] | echohl NONE
      echon item[-1:-1] . " "
    else
      echon item . " "
    endif
  endfor

  return s:true
endfunction

function! s:buf_delete(bang) "{{{2
  let file = fnamemodify(expand('%'), ':p')
  let g:buf_delete_safety_mode = 1
  let g:buf_delete_custom_command = "system(printf('%s %s', 'gomi', shellescape(file)))"

  if filereadable(file)
    if empty(a:bang)
      redraw | echo 'Delete "' . file . '"? [y/N]: '
    endif
    if !empty(a:bang) || nr2char(getchar()) ==? 'y'
      silent! update
      if g:buf_delete_safety_mode == 1
        silent! execute has('clipboard') ? '%yank "*' : '%yank'
      endif
      if eval(g:buf_delete_custom_command == "" ? delete(file) : g:buf_delete_custom_command) == 0
        let bufname = bufname(fnamemodify(file, ':p'))
        if bufexists(bufname) && buflisted(bufname)
          execute "bwipeout" bufname
        endif
        echo "Deleted '" . file . "', successfully!"
        return s:true
      endif
      "echo "Could not delete '" . file . "'"
      return s:error("Could not delete '" . file . "'")
    else
      echo "Do nothing."
    endif
  else
    "echohl WarningMsg | echo "The '" . file . "' does not exist." | echohl NONE
    return s:error(echo "The '" . file . "' does not exist")
  endif
endfunction

function! s:count_buffers() "{{{2
  let l:count = 0
  for i in range(1, bufnr('$'))
    if bufexists(i) && buflisted(i)
      let l:count += 1
    endif
  endfor
  return l:count
endfunction

function! s:get_buflists(...) "{{{2
  if a:0 && a:1 ==# 'n'
    silent bnext
  elseif a:0 && a:1 ==# 'p'
    silent bprev
  endif

  let list  = ''
  let lists = []
  for buf in range(1, bufnr('$'))
    if bufexists(buf) && buflisted(buf)
      let list  = bufnr(buf) . "#" . fnamemodify(bufname(buf), ':t')
      let list .= getbufvar(buf, "&modified") ? '+' : ''
      if bufnr('%') ==# buf
        let list = "[" . list . "]"
      else
        let list = " " . list . " "
      endif
      call add(lists, list)
    endif
  endfor
  redraw | echo join(lists, "")
endfunction

function! s:smart_bwipeout(mode) "{{{2
  " Bwipeout! all buffers except current buffer.
  if a:mode == 1
    for i in range(1, bufnr('$'))
      if bufexists(i)
        if bufnr('%') ==# i | continue | endif
        execute 'silent bwipeout! ' . i
      endif
    endfor
    return
  endif

  if a:mode == 0
    if winnr('$') != 1
      quit
      return
    elseif tabpagenr('$') != 1
      tabclose
      return
    endif
  endif

  let bufname = empty(bufname(bufnr('%'))) ? bufnr('%') . "#" : bufname(bufnr('%'))
  if &modified == 1
    echo printf("'%s' is unsaved. Quit!? [y(f)/N/w] ", bufname)
    let c = nr2char(getchar())

    if c ==? 'w'
      let filename = ''
      if bufname(bufnr("%")) ==# filename
        redraw
        while empty(filename)
          let filename = input('Tell me filename: ')
        endwhile
      endif
      execute "write " . filename
      silent bwipeout!

    elseif c ==? 'y' || c ==? 'f'
      silent bwipeout!
    else
      redraw
      echo "Do nothing"
      return
    endif
  else
    silent bwipeout
  endif

  if s:has_plugin("vim-buftabs")
    echo "Bwipeout " . bufname
  else
    redraw
    call <SID>get_buflists()
  endif
endfunction

function! s:smart_bchange(mode) "{{{2
  let mode = a:mode

  " If window splitted, no working
  if winnr('$') != 1
    " Normal bnext/bprev
    execute 'silent' mode ==? 'n' ? 'bnext' : 'bprevious'
    if exists("*s:get_buflists") && exists("*s:count_buffers")
      if s:count_buffers() > 1
        call s:get_buflists()
      endif
    endif
    return
  endif

  " Get all buffer numbers in tabpages
  let tablist = []
  for i in range(tabpagenr('$'))
    call add(tablist, tabpagebuflist(i + 1))
  endfor

  " Get buffer number
  execute 'silent' mode ==? 'n' ? 'bnext' : 'bprevious'
  let bufnr = bufnr('%')
  execute 'silent' mode ==? 'n' ? 'bprevious' : 'bnext'

  " Check next/prev buffer number if exists in l:tablist
  let nextbuf = []
  call add(nextbuf, bufnr)
  if index(tablist, nextbuf) >= 0
    execute 'silent tabnext' index(tablist, nextbuf) + 1
  else
    " Normal bnext/bprev
    execute 'silent' mode ==? 'n' ? 'bnext' : 'bprevious'
  endif
endfunction

function! s:buf_enqueue(buf) "{{{2
  let buf = fnamemodify(a:buf, ':p')
  if bufexists(buf) && buflisted(buf) && filereadable(buf)
    let idx = match(s:bufqueue ,buf)
    if idx != -1
      call remove(s:bufqueue, idx)
    endif
    call add(s:bufqueue, buf)
  endif
endfunction

function! s:buf_dequeue(buf) "{{{2
  if empty(s:bufqueue)
    throw 'bufqueue: Empty queue.'
  endif

  if a:buf =~# '\d\+'
    return remove(s:bufqueue, a:buf)
  else
    return remove(s:bufqueue, index(s:bufqueue, a:buf))
  endif
endfunction

function! s:buf_restore() "{{{2
  try
    execute 'edit' s:buf_dequeue(-1)
  catch /^bufqueue:/
    "echohl ErrorMsg
    "echomsg v:exception
    "echohl None
    call s:error(v:exception)
  endtry
endfunction

function! s:win_tab_switcher(...) "{{{2
  let minus = 0
  if &laststatus == 1 && winnr('$') != 1
    let minus += 1
  elseif &laststatus == 2
    let minus += 1
  endif
  let minus += &cmdheight
  if &showtabline == 1 && tabpagenr('$') != 1
    let minus += 1
  elseif &showtabline == 2
    let minus += 1
  endif

  let is_split   = winheight(0) != &lines - minus
  let is_vsplit  = winwidth(0)  != &columns
  let is_tabpage = tabpagenr('$') >= 2

  let buffer_switcher = get(g:, 'buffer_switcher', 0)
  if a:0 && a:1 ==# 'l'
    if is_tabpage
      if tabpagenr() == tabpagenr('$')
        if !is_split && !is_vsplit
          if buffer_switcher
            silent bnext
          else
            echohl WarningMsg
            echo 'Last tabpages'
            echohl None
          endif
        endif
        if (is_split || is_vsplit) && winnr() == winnr('$')
          if buffer_switcher
            silent bnext
          else
            echohl WarningMsg
            echo 'Last tabpages'
            echohl None
          endif
        elseif (is_split || is_vsplit) && winnr() != winnr('$')
          silent wincmd w
        endif
      else
        if !is_split && !is_vsplit
          silent tabnext
        endif
        if (is_split || is_vsplit) && winnr() == winnr('$')
          silent tabnext
        elseif (is_split || is_vsplit) && winnr() != winnr('$')
          silent wincmd w
        endif
      endif
    else
      if !is_split && !is_vsplit
        if buffer_switcher
          silent bnext
        else
          echohl WarningMsg
          echo 'Last tabpages'
          echohl None
        endif
      endif
      if (is_split || is_vsplit) && winnr() == winnr('$')
        if buffer_switcher
          silent bnext
        else
          echohl WarningMsg
          echo 'Last tabpages'
          echohl None
        endif
      else
        silent wincmd w
      endif
    endif
  endif
  if a:0 && a:1 ==# 'h'
    if is_tabpage
      if tabpagenr() == 1
        if !is_split && !is_vsplit
          if buffer_switcher
            silent bprevious
          else
            echohl WarningMsg
            echo 'First tabpages'
            echohl None
          endif
        endif
        if (is_split || is_vsplit) && winnr() == 1
          if buffer_switcher
            silent bprevious
          else
            echohl WarningMsg
            echo 'First tabpages'
            echohl None
          endif
        elseif (is_split || is_vsplit) && winnr() != 1
          silent wincmd W
        endif
      else
        if !is_split && !is_vsplit
          silent tabprevious
        endif
        if (is_split || is_vsplit) && winnr() == 1
          silent tabprevious
        elseif (is_split || is_vsplit) && winnr() != 1
          silent wincmd W
        endif
      endif
    else
      if !is_split && !is_vsplit
        if buffer_switcher
          silent bprevious
        else
          echohl WarningMsg
          echo 'First tabpages'
          echohl None
        endif
      endif
      if (is_split || is_vsplit) && winnr() == 1
        if buffer_switcher
          silent bprevious
        else
          echohl WarningMsg
          echo 'First tabpages'
          echohl None
        endif
      else
        silent wincmd W
      endif
    endif
  endif

  if s:has_plugin("vim-buftabs")
  else
    redraw
    call <SID>get_buflists()
  endif
endfunction

function! s:find_tabnr(bufnr) "{{{2
  for tabnr in range(1, tabpagenr("$"))
    if index(tabpagebuflist(tabnr), a:bufnr) !=# -1
      return tabnr
    endif
  endfor
  return -1
endfunction

function! s:find_winnr(bufnr) "{{{2
  for winnr in range(1, winnr("$"))
    if a:bufnr ==# winbufnr(winnr)
      return winnr
    endif
  endfor
  return 1
endfunction

function! s:recycle_open(default_open, path) "{{{2
  let default_action = a:default_open . ' ' . a:path
  if bufexists(a:path)
    let bufnr = bufnr(a:path)
    let tabnr = s:find_tabnr(bufnr)
    if tabnr ==# -1
      execute default_action
      return
    endif
    execute 'tabnext ' . tabnr
    let winnr = s:find_winnr(bufnr)
    execute winnr . 'wincmd w'
  else
    execute default_action
  endif
endfunction

" Utility: in vimrc {{{1
" In this section, the settings a higher priority than the setting items
" of the other sections will be described.
"==============================================================================

" Display B4B4R07 logo start-up. {{{2
if !s:has_plugin('neobundle.vim')
  command! StartupLogo call <SID>startup_logo()
  augroup vimrc-without-plugin
    autocmd!
    autocmd VimEnter * if !argc() | call <SID>startup_logo() | endif
  augroup END
  "autocmd VimEnter * nested if @% == '' && s:GetBufByte() == 0 | edit $MYVIMRC | endif
  "function! s:GetBufByte()
  "    let byte = line2byte(line('$') + 1)
  "    if byte == -1
  "        return 0
  "    else
  "        return byte - 1
  "    endif
  "endfunction
endif

" Builtin MRU {{{2
if !s:has_plugin('mru.vim')
  " MRU configuration variables {{{3
  if !exists('s:MRU_File')
    if has('unix') || has('macunix')
      let s:MRU_File = $HOME . '/.vim_mru_files'
    else
      let s:MRU_File = $VIM . '/_vim_mru_files'
      if has('win32')
        if $USERPROFILE != ''
          let s:MRU_File = $USERPROFILE . '\_vim_mru_files'
        endif
      endif
    endif
  endif

  function! s:MRU_LoadList() "{{{3
    if filereadable(s:MRU_File)
      let s:MRU_files = readfile(s:MRU_File)
      if s:MRU_files[0] =~# '^#'
        call remove(s:MRU_files, 0)
      else
        let s:MRU_files = []
      endif
    else
      let s:MRU_files = []
    endif
  endfunction

  function! s:MRU_SaveList() "{{{3
    let l = []
    call add(l, '# Most recently used files list')
    call extend(l, s:MRU_files)
    call writefile(l, s:MRU_File)
  endfunction
  function! s:MRU_AddList(buf) "{{{3
    if s:mru_list_locked
      return
    endif

    let fname = fnamemodify(bufname(a:buf + 0), ':p')
    if fname == ''
      return
    endif

    if &buftype != ''
      return
    endif

    if index(s:MRU_files, fname) == -1
      if !filereadable(fname)
        return
      endif
    endif

    call s:MRU_LoadList()
    call filter(s:MRU_files, 'v:val !=# fname')
    call insert(s:MRU_files, fname, 0)

    "let s:MRU_Max_Entries = 100
    "if len(s:MRU_files) > s:MRU_Max_Entries
    " call remove(s:MRU_files, s:MRU_Max_Entries, -1)
    "endif

    call s:MRU_SaveList()

    let bname = '__MRU_Files__'
    let winnum = bufwinnr(bname)
    if winnum != -1
      let cur_winnr = winnr()
      call s:MRU_Create_Window()
      if winnr() != cur_winnr
        exe cur_winnr . 'wincmd w'
      endif
    endif
  endfunction

  function! s:MRU_RemoveList() "{{{3
    call s:MRU_LoadList()
    let lnum = line('.')
    call remove(s:MRU_files, line('.')-1)
    call s:MRU_SaveList()
    close
    call s:MRU_Create_Window()
    call cursor(lnum, 1)
  endfunction

  function! s:MRU_Open_File() range "{{{3
    for f in getline(a:firstline, a:lastline)
      if f == ''
        continue
      endif

      let file = substitute(f, '^.*| ','','')

      let winnum = bufwinnr('^' . file . '$')
      silent quit
      if winnum != -1
        return
      else
        if &filetype ==# 'mru'
          silent quit
        endif
      endif

      exe 'edit ' . fnameescape(substitute(file, '\\', '/', 'g'))
    endfor
  endfunction

  function! s:MRU_Create_Window() "{{{3
    if &filetype == 'mru' && bufname("%") ==# '__MRU_Files__'
      quit
      return
    endif

    call s:MRU_LoadList()
    if empty(s:MRU_files)
      echohl WarningMsg | echo 'MRU file list is empty' | echohl None
      return
    endif

    let bname = '__MRU_Files__'
    let winnum = bufwinnr(bname)
    if winnum != -1
      if winnr() != winnum
        exe winnum . 'wincmd w'
      endif

      setlocal modifiable
      " Delete the contents of the buffer to the black-hole register
      silent! %delete _
    else
      " If the __MRU_Files__ buffer exists, then reuse it. Otherwise open
      " a new buffer
      let bufnum = bufnr(bname)
      if bufnum == -1
        let wcmd = bname
      else
        let wcmd = '+buffer' . bufnum
      endif
      let wcmd = bufnum == -1 ? bname : '+buffer' . bufnum
      let s:MRU_Window_Height = &lines / 3
      exe 'silent! botright ' . s:MRU_Window_Height . 'split ' . wcmd
    endif

    " Mark the buffer as scratch
    setlocal buftype=nofile
    setlocal bufhidden=delete
    setlocal noswapfile
    setlocal nowrap
    setlocal nobuflisted
    setlocal filetype=mru
    setlocal winfixheight
    setlocal modifiable

    let old_cpoptions = &cpoptions
    set cpoptions&vim

    " Create mappings to select and edit a file from the MRU list
    nnoremap <buffer> <silent> <CR>   :call <SID>MRU_Open_File()<CR>
    vnoremap <buffer> <silent> <CR>   :call <SID>MRU_Open_File()<CR>
    nnoremap <buffer> <silent> <S-CR> :call <SID>MRU_Open_File_Tab()<CR>
    vnoremap <buffer> <silent> <S-CR> :call <SID>MRU_Open_File_Tab()<CR>
    nnoremap <buffer> <silent> K      :call <SID>MRU_RemoveList()<CR>
    nnoremap <buffer> <silent> S      :setlocal modifiable<CR>:sort<CR>:setlocal nomodifiable<CR>

    " Restore the previous cpoptions settings
    let &cpoptions = old_cpoptions

    let output = copy(s:MRU_files)
    let idx = 0
    for file in output
      if !filereadable(file)
        call remove(output, idx)
        continue
      endif
      let idx += 1
    endfor

    silent! 0put =output

    " Delete the empty line at the end of the buffer
    silent! $delete _
    let glist = getline(1, '$')
    let max = 0
    let max_h = 0
    for idx in range(0, len(glist)-1)
      if strlen(fnamemodify(glist[idx], ':t')) > max
        let max = strlen(fnamemodify(glist[idx], ':t'))
      endif
      if strlen(substitute(fnamemodify(glist[idx], ':p:h'), '^.*\/', '', '')) > max_h
        let max_h = strlen(substitute(fnamemodify(glist[idx], ':p:h'), '^.*\/', '', ''))
      endif
    endfor
    for idx in range(0, len(glist)-1)
      let glist[idx] = printf("%-" . max .  "s | %-" . max_h . "s | %s" ,
            \ fnamemodify(glist[idx], ':t'), substitute(fnamemodify(glist[idx], ':p:h'), '^.*\/', '', ''), glist[idx])
    endfor
    silent! %delete _
    call setline(1, glist)
    if glist[idx] == '| '
      silent! $delete _
    endif

    exe 'syntax match Directory display ' . '"'. '|\zs[^|]*\ze|'. '"'
    exe 'syntax match Constant  display ' . '"' . '[^|]*[\/]' . '"'

    " Move the cursor to the beginning of the file
    normal! gg

    setlocal nonumber cursorline nomodifiable
  endfunction

  " MRU Essentials {{{3
  let s:mru_list_locked = 0
  call s:MRU_LoadList()
  command! MRU call s:MRU_Create_Window()
  augroup mru-files-vimrc
    autocmd!
    autocmd BufRead      * call s:MRU_AddList(expand('<abuf>'))
    autocmd BufNewFile   * call s:MRU_AddList(expand('<abuf>'))
    autocmd BufWritePost * call s:MRU_AddList(expand('<abuf>'))
    autocmd QuickFixCmdPre  *grep* let s:mru_list_locked = 1
    autocmd QuickFixCmdPost *grep* let s:mru_list_locked = 0
  augroup END
endif

" Add execute permission {{{2
if s:vimrc_add_execute_perm == s:true
  if executable('chmod')
    augroup auto-add-executable
      autocmd!
      autocmd BufWritePost * call <SID>add_permission_x()
    augroup END

    function! s:add_permission_x()
      let file = expand('%:p')
      if !executable(file)
        if getline(1) =~# '^#!'
              \ || &filetype =~ "\\(z\\|c\\|ba\\)\\?sh$"
              \ && input(printf('"%s" is not perm 755. Change mode? [y/N] ', expand('%:t'))) =~? '^y\%[es]$'
          call system("chmod 755 " . shellescape(file))
          redraw | echo "Set permission 755!"
        endif
      endif
    endfunction
  endif
endif

" Restore cursor position {{{2
if s:vimrc_restore_cursor_position == s:true
  function! s:restore_cursor_postion()
    if line("'\"") <= line("$")
      normal! g`"
      return 1
    endif
  endfunction
  augroup restore-cursor-position
    autocmd!
    autocmd BufWinEnter * call <SID>restore_cursor_postion()
  augroup END
endif

" Restore the buffer that has been deleted {{{2
let s:bufqueue = []
augroup buffer-queue-restore
  autocmd!
  autocmd BufDelete * call <SID>buf_enqueue(expand('#'))
augroup END

" Automatically get buffer list {{{2
if !s:has_plugin('vim-buftabs')
  augroup bufenter-get-buffer-list
    autocmd!
    " Escape getting buflist by "@% != ''" when "VimEnter"
    autocmd BufEnter,BufAdd,BufWinEnter * if @% != '' | call <SID>get_buflists() | endif
  augroup END
endif

" Automatically cd parent directory when opening the file {{{2
function! s:cd_file_parentdir()
  let dir = expand("%:p:h")
  if !isdirectory(dir)
    call s:auto_mkdir(dir, v:cmdbang)
  endif
  silent! execute ":lcd " . dir
endfunction
command! Cdp call <SID>cd_file_parentdir()

if s:vimrc_auto_cd_file_parentdir == s:true
  augroup cd-file-parentdir
    autocmd!
    autocmd BufRead,BufEnter * call <SID>cd_file_parentdir()
  augroup END
endif

" Backup automatically {{{2
if s:is_windows
  set nobackup
else
  set backup
  call s:mkdir('~/.vim/backup')
  augroup backup-files-automatically
    autocmd!
    autocmd BufWritePre * call s:backup_files()
  augroup END

  function! s:backup_files()
    let dir = strftime("~/.backup/vim/%Y/%m/%d", localtime())
    if !isdirectory(dir)
      call system("mkdir -p " . dir)
      call system("chown goth:staff " . dir)
    endif
    execute "set backupdir=" . dir
    execute "set backupext=." . strftime("%H_%M_%S", localtime())
  endfunction
endif

" Swap settings {{{2
call s:mkdir('~/.vim/swap')
set noswapfile
set directory=~/.vim/swap

" Vimp: a development tool for vim plugins {{{2
let s:vimp = {
      \   "list": [
      \     "vim-dirvish",
      \     "vim-shellutils",
      \     "vim-surround",
      \     "yankround.vim",
      \     "neocomplete.vim",
      \   ],
      \   "dir":  ".vimp",
      \   "file": "Vimpfile",
      \ }

function! s:vimp.parse()
  let list = []

  for dep in readfile(self.file)
    if isdirectory(dep)
      let res = fnamemodify(dep, ":p")
      call add(list, res)
    else
      let res = finddir(fnamemodify(dep, ":t"), expand("$HOME/.vim/bundle"))
      if !empty(res)
        call add(list, res)
      endif
    endif
  endfor

  return list
endfunction

function! s:vimp.symbolic()
  if !isdirectory(self.dir)
    call s:mkdir(self.dir)
  endif

  for link in s:vimp.parse()
    call system(printf("ln -snf %s %s", link, self.dir))
  endfor
endfunction

function! s:vimp.gen()
  call writefile(self.list, self.file)
endfunction

function! s:vimp.start()
  if !filereadable(self.file)
    call s:vimp.gen()
  endif
  call s:vimp.symbolic()
  echo readfile(self.file)
  call s:echomsg("WarningMsg", "Restart Vim")
endfunction

function! s:vimp.end()
  try
    call s:rm(self.file)
    call s:rm(self.dir)
  catch
  finally
    call s:echomsg("WarningMsg", "Restart Vim")
  endtry
endfunction

command! VimpStart  call s:vimp.start()
command! VimpEnd    call s:vimp.end()

function! HomedirOrBackslash() "{{{2
  if getcmdtype() == ':' && (getcmdline() =~# '^e ' || getcmdline() =~? '^r\?!' || getcmdline() =~? '^cd ')
    return '~/'
  else
    return '\'
  endif
endfunction

function! GetDate() "{{{2
  return strftime("%Y/%m/%d %H:%M")
endfunction

function! GetDocumentPosition() "{{{2
  return float2nr(str2float(line('.')) / str2float(line('$')) * 100) . "%"
endfunction

function! GetCharacterCode() "{{{2
  let str = iconv(matchstr(getline('.'), '.', col('.') - 1), &enc, &fenc)
  let out = '0x'
  for i in range(strlen(str))
    let out .= printf('%02X', char2nr(str[i]))
  endfor
  if str ==# ''
    let out .= '00'
  endif
  return out
endfunction

function! GetFileSize() "{{{2
  let size = &encoding ==# &fileencoding || &fileencoding ==# ''
        \        ? line2byte(line('$') + 1) - 1 : getfsize(expand('%'))

  if size < 0
    let size = 0
  endif
  for unit in ['B', 'KB', 'MB']
    if size < 1024
      return size . unit
    endif
    let size = size / 1024
  endfor
  return size . 'GB'
endfunction

function! GetBufname(bufnr, ...) "{{{2
  let bufname = bufname(a:bufnr)
  if bufname =~# '^[[:alnum:].+-]\+:\\\\'
    let bufname = substitute(bufname, '\\', '/', 'g')
  endif
  let buftype = getbufvar(a:bufnr, '&buftype')
  if bufname ==# ''
    if buftype ==# ''
      return '[No Name]'
    elseif buftype ==# 'quickfix'
      return '[Quickfix List]'
    elseif buftype ==# 'nofile' || buftype ==# 'acwrite'
      return '[Scratch]'
    endif
  endif
  if buftype ==# 'nofile' || buftype ==# 'acwrite'
    return bufname
  endif
  if a:0 && a:1 ==# 't'
    return fnamemodify(bufname, ':t')
  elseif a:0 && a:1 ==# 'f'
    return (fnamemodify(bufname, ':~:p'))
  elseif a:0 && a:1 ==# 's'
    return pathshorten(fnamemodify(bufname, ':~:h')).'/'.fnamemodify(bufname, ':t')
  endif
  return bufname
endfunction

function! GetFileInfo() "{{{2
  let line  = ''
  if bufname(bufnr("%")) == ''
    let line .= 'No name'
  else
    let line .= '"'
    let line .= expand('%:p:~')
    let line .= ' (' . line('.') . '/' . line('$') . ') '
    "let line .= '--' . 100 * line('.') / line('$') . '%--'
    let line .= GetDocumentPosition()
    let line .= '"'
  endif
  return line
endfunction

function! GetHighlight(hi) "{{{2
  redir => hl
  silent execute 'highlight ' . a:hi
  redir END
  return substitute(hl, '.*xxx ', '', '')
endfunction

function! WordCount(...) "{{{2
  if a:0 == 0
    if exists("s:WordCountStr")
      return s:WordCountStr
    endif
    return
  endif
  let cidx = 3
  silent! let cidx = s:WordCountDict[a:1]
  let s:WordCountStr = ''
  let s:saved_status = v:statusmsg
  exec "silent normal! g\<c-g>"
  if v:statusmsg !~ '^--'
    let str = ''
    silent! let str = split(v:statusmsg, ';')[cidx]
    let cur = str2nr(matchstr(str, '\d\+'))
    let end = str2nr(matchstr(str, '\d\+\s*$'))
    if a:1 == 'char'
      let cr = &ff == 'dos' ? 2 : 1
      let cur -= cr * (line('.') - 1)
      let end -= cr * line('$')
    endif
    let s:WordCountStr = printf('%d/%d', cur, end)
    let s:WordCountStr = printf('%d', end)
  endif
  let v:statusmsg = s:saved_status
  return s:WordCountStr
endfunction


" Appearance: {{{1
" In this section, interface of Vim, that is, colorscheme, statusline and
" tabpages line is set.
"==============================================================================

" Essentials
syntax enable on

"Colorscheme "{{{2
set background=dark
if !has('gui_running')
  set background=dark
endif
set t_Co=256
if &t_Co < 256
  colorscheme default
else
  if has('gui_running') && !s:is_windows
    " For MacVim, only
    if s:has_plugin('solarized.vim')
      try
        colorscheme solarized-cui
      catch
        colorscheme solarized
      endtry
    endif
  else
    " Vim for CUI
    if s:has_plugin('solarized.vim')
      try
        colorscheme solarized-cui
      catch
        colorscheme solarized
      endtry
    elseif s:has_plugin('jellybeans.vim')
      colorscheme jellybeans
    elseif s:has_plugin('vim-hybrid')
      colorscheme hybrid
    else
      if s:is_windows
        colorscheme default
      else
        colorscheme desert
      endif
    endif
  endif
endif

" Tabline {{{2
set showtabline=2
set tabline=%!MakeTabLine()

function! s:tabpage_label(n) "{{{3
  let n = a:n
  let bufnrs = tabpagebuflist(n)
  let curbufnr = bufnrs[tabpagewinnr(n) - 1]

  let hi = n == tabpagenr() ? 'TabLineSel' : 'TabLine'

  let label = ''
  let no = len(bufnrs)
  if no == 1
    let no = ''
  endif
  let mod = len(filter(bufnrs, 'getbufvar(v:val, "&modified")')) ? '+' : ''
  let sp = (no . mod) ==# '' ? '' : ' '
  let fname = GetBufname(curbufnr, 's')

  if no !=# ''
    let label .= '%#' . hi . 'Number#' . no
  endif
  let label .= '%#' . hi . '#'
  let label .= fname . sp . mod

  return '%' . a:n . 'T' . label . '%T%#TabLineFill#'
endfunction
function! MakeTabLine() "{{{3
  let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
  let sep = ' | '
  let tabs = join(titles, sep) . sep . '%#TabLineFill#%T'

  "hi TabLineFill ctermfg=white
  let info = '%#TabLineFill#'
  let info .= fnamemodify(getcwd(), ':~') . ' '
  return tabs . '%=' . info
endfunction
function! GuiTabLabel() "{{{3
  let label = ''
  let bufnrlist = tabpagebuflist(v:lnum)

  " Append the tab number
  "let label .= v:lnum.': '
  " Append the buffer name
  let name = bufname(bufnrlist[tabpagewinnr(v:lnum) - 1])
  if name == ''
    " give a name to no-name documents
    if &buftype=='quickfix'
      let name = '[Quickfix List]'
    else
      let name = '[No Name]'
    endif
  else
    " get only the file name
    let name = fnamemodify(name,":t")
  endif
  "let label .= name
  let label .= GetBufname('%', 't')
  " Append the number of windows in the tab page
  let wincount = tabpagewinnr(v:lnum, '$')

  " Add '+' if one of the buffers in the tab page is modified
  for bufnr in l:bufnrlist
    if getbufvar(bufnr, "&modified")
      let l:label .= ' +'
      break
    endif
  endfor
  let wincount = wincount == 1 ? '' : wincount . ' '

  ""return label . '  [' . wincount . ']'
  return wincount . label
endfunction "}}}

" StatusLine {{{2
set laststatus=2

highlight BlackWhite ctermfg=black ctermbg=white cterm=none guifg=black guibg=white gui=none
highlight WhiteBlack ctermfg=white ctermbg=black cterm=none guifg=white guibg=black gui=none

function! MakeStatusLine()
  let line = ''
  "let line .= '%#BlackWhite#'
  let line .= '[%n] '
  let line .= '%f'
  let line .= ' %m'
  let line .= '%<'
  "let line .= '%#StatusLine#'

  let line .= '%='
  let line .= '%#BlackWhite#'
  let line .= '%y'
  let line .= "[%{(&fenc!=#''?&fenc:&enc).(&bomb?'(BOM)':'')}:"
  let line .= "%{&ff.(&bin?'(BIN'.(&eol?'':'-noeol').')':'')}]"
  let line .= '%r'
  let line .= '%h'
  let line .= '%w'
  let line .= ' %l/%LL %2vC'
  let line .= ' %3p%%'

  if s:vimrc_statusline_manually == s:true
    return line
  else
    return ''
  endif
endfunction

function! MakeBigStatusLine()
  if s:vimrc_statusline_manually == s:true
    set statusline=
    set statusline+=%#BlackWhite#
    set statusline+=[%n]:
    if filereadable(expand('%'))
      set statusline+=%{GetBufname(bufnr('%'),'s')}
    else
      set statusline+=%F
    endif
    set statusline+=\ %m
    set statusline+=%#StatusLine#

    set statusline+=%=
    set statusline+=%#BlackWhite#
    if exists('*TrailingSpaceWarning')
      "set statusline+=%{TrailingSpaceWarning()}
    endif
    set statusline+=%y%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}
    set statusline+=%r
    set statusline+=%h
    set statusline+=%w
    if exists('*GetFileSize')
      set statusline+=[%{GetFileSize()}]
    endif
    if exists('*GetCharacterCode')
      set statusline+=[%{GetCharacterCode()}]
    endif
    set statusline+=\ %4l/%4LL,%3cC\ %3p%%
    if exists('*WordCount')
      set statusline+=\ [WC=%{WordCount()}]
    endif
    if exists('*GetDate')
      set statusline+=\ (%{GetDate()})
    endif
  endif
endfunction

if !s:has_plugin('lightline.vim')
  call MakeBigStatusLine()
  if s:vimrc_statusline_manually == s:true
    " Refresh Manually StatusLine
    augroup automatically-statusline
      autocmd!
      autocmd BufEnter * call MakeBigStatusLine()
    augroup END
  endif

  augroup minimal-statusline
    autocmd!
    autocmd WinEnter,CursorMoved * if winwidth(0) <  &columns | set statusline=%!MakeStatusLine() | endif
  augroup END
endif


" Emphasize statusline in the insert mode {{{2
if s:vimrc_colorize_statusline_insert == s:true
  if !s:has_plugin('lightline.vim')
    augroup colorize-statusline-insert
      autocmd!
      autocmd InsertEnter * call s:colorize_statusline_insert('Enter')
      autocmd InsertLeave * call s:colorize_statusline_insert('Leave')
    augroup END

    function! ReverseHighlight(hi)
      let hl = a:hi
      let hl = substitute(hl, 'fg', 'swp', 'g')
      let hl = substitute(hl, 'bg', 'fg',  'g')
      let hl = substitute(hl, 'swp', 'bg', 'g')
      return hl
    endfunction

    let s:hi_insert = 'highlight StatusLine ' . ReverseHighlight(GetHighlight('ModeMsg'))
    let s:slhlcmd = ''

    function! s:colorize_statusline_insert(mode)
      if a:mode == 'Enter'
        let s:slhlcmd = 'highlight StatusLine ' . GetHighlight('StatusLine')
        silent execute s:hi_insert

      elseif a:mode == 'Leave'
        highlight clear StatusLine
        silent execute s:slhlcmd
      endif

    endfunction
  endif
endif

" Cursor line/column {{{2
set cursorline
augroup auto-cursorcolumn-appear
  autocmd!
  autocmd CursorMoved,CursorMovedI * call s:auto_cursorcolumn('CursorMoved')
  autocmd CursorHold,CursorHoldI   * call s:auto_cursorcolumn('CursorHold')
  autocmd BufEnter * call s:auto_cursorcolumn('WinEnter')
  autocmd BufLeave * call s:auto_cursorcolumn('WinLeave')

  let s:cursorcolumn_lock = 0
  function! s:auto_cursorcolumn(event)
    if a:event ==# 'WinEnter'
      setlocal cursorcolumn
      let s:cursorcolumn_lock = 2
    elseif a:event ==# 'WinLeave'
      setlocal nocursorcolumn
    elseif a:event ==# 'CursorMoved'
      setlocal nocursorcolumn
      if s:cursorcolumn_lock
        if 1 < s:cursorcolumn_lock
          let s:cursorcolumn_lock = 1
        else
          setlocal nocursorcolumn
          let s:cursorcolumn_lock = 0
        endif
      endif
    elseif a:event ==# 'CursorHold'
      setlocal cursorcolumn
      let s:cursorcolumn_lock = 1
    endif
  endfunction
augroup END

" Options: {{{1
" Set options (boolean, number, string). General vim behavior.
" For more information about options, see :help 'option-list'.
"==============================================================================

set number

" Determines the maximum number of items to show in the popup menu.
" zero as much space as available is used.
set pumheight=10

" Don't redraw while executing macros
set lazyredraw

" Fast terminal connection
set ttyfast

" Enable the mode line
set modeline

" The length of the mode line
set modelines=5

" Vim internal help with the command K
set keywordprg=:help

" Language help
set helplang& helplang=ja

" Ignore case
set ignorecase

" Smart ignore case
set smartcase

" Enable the incremental search
set incsearch

" Emphasize the search pattern
set hlsearch

" Have Vim automatically reload changed files on disk. Very useful when using
" git and switching between branches
set autoread

" Automatically write buffers to file when current window switches to another
" buffer as a result of :next, :make, etc. See :h autowrite.
set autowrite

" Behavior when you switch buffers
set switchbuf=useopen,usetab,newtab

" Moves the cursor to the same column when cursor move
set nostartofline

" Use tabs instead of spaces
"set noexpandtab
set expandtab

" When starting a new line, indent in automatic
set autoindent

" The function of the backspace
set backspace=indent,eol,start

" When the search is finished, search again from the BOF
set wrapscan

" Emphasize the matching parenthesis
set showmatch

" Blink on matching brackets
set matchtime=1

" Increase the corresponding pairs
set matchpairs& matchpairs+=<:>

" Extend the command line completion
set wildmenu

" Wildmenu mode
set wildmode=longest,full

" Ignore compiled files
set wildignore&
set wildignore=.git,.hg,.svn
set wildignore+=*.jpg,*.jpeg,*.bmp,*.gif,*.png
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest,*.so,*.out,*.class
set wildignore+=*.swp,*.swo,*.swn
set wildignore+=*.DS_Store

" Show line and column number
set ruler
set rulerformat=%m%r%=%l/%L

" 1 tab == 4 spaces
set shiftwidth=4
set tabstop=4

" String to put at the start of lines that have been wrapped.
let &showbreak = '+++ '

" Always display a status line
set laststatus=2

" Set command window height to reduce number of 'Press ENTER...' prompts
set cmdheight=2

" Show current mode (insert, visual, normal, etc.)
set showmode

" Show last command in status line
set showcmd

" Lets vim set the title of the console
set notitle

" When you create a new line, perform advanced automatic indentation
set smartindent

" Blank is inserted only the number of 'shiftwidth'.
set smarttab

" Moving the cursor left and right will be modern.
set whichwrap=b,s,h,l,<,>,[,]

" Hide buffers instead of unloading them
set hidden

" The maximum width of the input text
set textwidth=0

set formatoptions&
set formatoptions-=t
set formatoptions-=c
set formatoptions-=r
set formatoptions-=o
set formatoptions-=v
set formatoptions+=l

" Identifying problems and bringing them to the foreground
set list
set listchars=tab:>-,trail:-,nbsp:%,extends:>,precedes:<,eol:<
set listchars=eol:<,tab:>.

" Increase or decrease items
set nrformats=alpha,hex

" Do not use alt key on Win
set winaltkeys=no

" Do not use visualbell
set novisualbell
set vb t_vb=

" Automatically equal size when opening
set noequalalways

" History size
set history=10000
set wrap

"set helpheight=999
set mousehide
set virtualedit=block
set virtualedit& virtualedit+=block

" Make it normal in UTF-8 in Unix.
set encoding=utf-8

" Select newline character (either or both of CR and LF depending on system) automatically
" Default fileformat.
set fileformat=unix
" Automatic recognition of a new line cord.
set fileformats=unix,dos,mac
" A fullwidth character is displayed in vim properly.
if exists('&ambiwidth')
  set ambiwidth=double
endif

set fileencodings=iso-2022-jp,cp932,sjis,euc-jp,utf-8

set foldenable
"set foldmethod=marker
"set foldopen=all
"set foldclose=all
set foldlevel=0
"set foldnestmax=2
set foldcolumn=2

" IM settings
" IM off when starting up
set iminsert=0 imsearch=0
" Use IM always
"set noimdisable
" Disable IM on cmdline
set noimcmdline

" Change some neccesary settings for win
if s:is_windows
  set shellslash "Exchange path separator
endif

if has('persistent_undo')
  set undofile
  let &undodir = $DOTVIM . '/undo'
  call s:mkdir(&undodir)
endif

" Use clipboard
if has('clipboard')
  set clipboard=unnamed
endif

if has('patch-7.4.338')
  set breakindent
endif

" GUI options {{{2
" No menubar
set guioptions-=m
" No frame
set guioptions-=C
set guioptions-=T
" No right scroolbar
set guioptions-=r
set guioptions-=R
" No left scroolbar
set guioptions-=l
set guioptions-=L
" No under scroolbar
set guioptions-=b

" Commands: {{{1
" User defined commands section.
"==============================================================================

" Source file
command! -nargs=? Source call <SID>load_source(empty(<q-args>) ? expand('%:p') : <q-args>)

" Ls like a shell-ls
command! -nargs=? -bang -complete=file Ls call s:ls(<q-args>, <q-bang>)

" Show all runtimepaths.
command! -bar RTP echo substitute(&runtimepath, ',', "\n", 'g')

" Make random string such as password
command! -nargs=? RandomString call s:random_string(<q-args>)

" View all mappings
command! -nargs=* -complete=mapping AllMaps map <args> | map! <args> | lmap <args>

" Get buffer queue list for restore
command! -nargs=0 BufQueue echo len(s:bufqueue)
      \ ? reverse(split(substitute(join(s:bufqueue, ' '), $HOME, '~', 'g')))
      \ : "No buffers in 's:bufqueue'."

" Get buffer list like ':ls'
command! -nargs=0 BufList call s:get_buflists()

" Smart bnext/bprev
command! Bnext call s:smart_bchange('n')
command! Bprev call s:smart_bchange('p')

" Show buffer kind.
command! -bar EchoBufKind setlocal bufhidden? buftype? swapfile? buflisted?

" Bwipeout(!) for all-purpose.
command! -nargs=0 -bang Bwipeout call <SID>smart_bwipeout(0, <q-bang>)

" Delete the current buffer and the file.
command! -bang -nargs=0 -complete=buffer Delete call s:buf_delete(<bang>0)

" Open a file
command! -nargs=? -complete=file Open call <SID>open(<q-args>)
command! -nargs=0                Op   call <SID>open('.')

" Get current file path
command! CopyCurrentPath call s:copy_current_path()

" Get current directory path
command! CopyCurrentDir call s:copy_current_path(1)

command! CopyPath CopyCurrentPath

" Remove EOL ^M
command! RemoveCr silent! %substitute/\r$//g | nohlsearch

" Remove EOL space
command! RemoveEolSpace silent! %substitute/ \+$//g | nohlsearch

" Remove blank line
command! RemoveBlankLine silent! global/^$/delete | nohlsearch | normal! ``

" Rename the current editing file
command! -nargs=? -complete=file Rename call s:rename(<q-args>, 'file')

" Change the current editing file extention
if v:version >= 730
  command! -nargs=? -complete=filetype ReExt  call s:rename(<q-args>, 'ext')
else
  command! -nargs=?                    ReExt  call s:rename(<q-args>, 'ext')
endif

" Make the notitle file called 'Junk'.
command! -nargs=0 JunkFile call s:make_junkfile()

" In particular effective when I am garbled in a terminal
command! -bang -bar -complete=file -nargs=? Utf8      edit<bang> ++enc=utf-8 <args>
command! -bang -bar -complete=file -nargs=? Iso2022jp edit<bang> ++enc=iso-2022-jp <args>
command! -bang -bar -complete=file -nargs=? Cp932     edit<bang> ++enc=cp932 <args>
command! -bang -bar -complete=file -nargs=? Euc       edit<bang> ++enc=euc-jp <args>
command! -bang -bar -complete=file -nargs=? Utf16     edit<bang> ++enc=ucs-2le <args>
command! -bang -bar -complete=file -nargs=? Utf16be   edit<bang> ++enc=ucs-2 <args>
command! -bang -bar -complete=file -nargs=? Jis       Iso2022jp<bang> <args>
command! -bang -bar -complete=file -nargs=? Sjis      Cp932<bang> <args>
command! -bang -bar -complete=file -nargs=? Unicode   Utf16<bang> <args>

" Tried to make a file note version
" Don't save it because dangerous.
command! WUtf8      setlocal fenc=utf-8
command! WIso2022jp setlocal fenc=iso-2022-jp
command! WCp932     setlocal fenc=cp932
command! WEuc       setlocal fenc=euc-jp
command! WUtf16     setlocal fenc=ucs-2le
command! WUtf16be   setlocal fenc=ucs-2
command! WJis       WIso2022jp
command! WSjis      WCp932
command! WUnicode   WUtf16

" Appoint a line feed
command! -bang -complete=file -nargs=? WUnix write<bang> ++fileformat=unix <args> | edit <args>
command! -bang -complete=file -nargs=? WDos  write<bang> ++fileformat=dos <args>  | edit <args>
command! -bang -complete=file -nargs=? WMac  write<bang> ++fileformat=mac <args>  | edit <args>

" Mappings: {{{1
" Mapping section.
"==============================================================================

" Essentials {{{2
" It is likely to be changed by $VIM/vimrc
if s:env.is_starting
  mapclear
  mapclear!
endif

" Use backslash
if s:is_mac
  noremap  \
  noremap \ 
endif

" Define mapleader
let g:mapleader = ','
let g:maplocalleader = ','

" Smart space mapping
" Notice: when starting other <Space> mappings in noremap, disappeared [Space]
nmap  <Space>   [Space]
xmap  <Space>   [Space]
nnoremap  [Space]   <Nop>
xnoremap  [Space]   <Nop>

" Function's commands {{{2
" MRU within the vimrc
if !s:has_plugin('mru.vim') 
  if exists('*s:MRU_Create_Window')
    nnoremap <silent> [Space]j :<C-u>call <SID>MRU_Create_Window()<CR>
  endif
else
  nnoremap <silent> [Space]j :<C-u>MRU<CR>
endif

" Smart folding close
nnoremap <silent> <C-_> :<C-u>call <SID>smart_foldcloser()<CR>

" Kill buffer
if s:has_plugin('vim-buftabs')
  nnoremap <silent> <C-x>k     :<C-u>call <SID>smart_bwipeout(0)<CR>
  nnoremap <silent> <C-x>K     :<C-u>call <SID>smart_bwipeout(1)<CR>
  nnoremap <silent> <C-x><C-k> :<C-u>call <SID>smart_bwipeout(2)<CR>
else
  "autocmd BufUnload,BufLeave,BufDelete,BufWipeout * call <SID>get_buflists()
  nnoremap <silent> <C-x>k     :<C-u>call <SID>smart_bwipeout(0)<CR>
  nnoremap <silent> <C-x>K     :<C-u>call <SID>smart_bwipeout(1)<CR>
  nnoremap <silent> <C-x><C-k> :<C-u>call <SID>smart_bwipeout(2)<CR>
  "nnoremap <silent> <C-x>k     :<C-u>silent call <SID>smart_bwipeout(0)<CR>:<C-u>call <SID>get_buflists()<CR>
  "nnoremap <silent> <C-x>K     :<C-u>silent call <SID>smart_bwipeout(1)<CR>:<C-u>call <SID>get_buflists()<CR>
  "nnoremap <silent> <C-x><C-k> :<C-u>silent call <SID>smart_bwipeout(2)<CR>:<C-u>call <SID>get_buflists()<CR>
endif

" Restore buffers
nnoremap <silent> <C-x>u :<C-u>call <SID>buf_restore()<CR>

" Delete buffers
"nnoremap <silent> <C-x>d     :call <SID>buf_delete('')<CR>
"nnoremap <silent> <C-x><C-d> :call <SID>buf_delete(1)<CR>
nnoremap <silent> <C-x>d     :Delete<CR>
nnoremap <silent> <C-x><C-d> :Delete!<CR>

" Open vimrc with tab
nnoremap <silent> [Space]. :call <SID>recycle_open('edit', $MYVIMRC)<CR>

" Make junkfile
nnoremap <silent> [Space]e  :<C-u>call <SID>make_junkfile()<CR>

" Easy typing tilda insted of backslash
cnoremap <expr> <Bslash> HomedirOrBackslash()

" Swap semicolon for colon {{{2
nnoremap ; :
vnoremap ; :
nnoremap q; q:
vnoremap q; q:
nnoremap : ;
vnoremap : ;

" Make less complex to escaping {{{2
inoremap jj <ESC>
cnoremap <expr> j getcmdline()[getcmdpos()-2] ==# 'j' ? "\<BS>\<C-c>" : 'j'
vnoremap <C-j><C-j> <ESC>
onoremap jj <ESC>
inoremap j[Space] j
onoremap j[Space] j

" Swap jk for gjgk {{{2
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap gj j
nnoremap gk k
vnoremap gj j
vnoremap gk k

" Buffers, windows, and tabpages {{{2
"nnoremap <silent> <C-j> :<C-u>call <SID>get_buflists('n')<CR>
"nnoremap <silent> <C-k> :<C-u>call <SID>get_buflists('p')<CR>
if s:has_plugin('vim-buftabs')
  nnoremap <silent> <C-j> :<C-u>silent bnext<CR>
  nnoremap <silent> <C-k> :<C-u>silent bprev<CR>
else
  nnoremap <silent> <C-j> :<C-u>silent bnext<CR>:<C-u>call <SID>get_buflists()<CR>
  nnoremap <silent> <C-k> :<C-u>silent bprev<CR>:<C-u>call <SID>get_buflists()<CR>
endif

" Windows
nnoremap s <Nop>
nnoremap sp :<C-u>split<CR>
nnoremap vs :<C-u>vsplit<CR>

function! s:vsplit_or_wincmdw()
  if winnr('$') == 1
    return ":vsplit\<CR>"
  else
    return ":wincmd w\<CR>"
  endif
endfunction
nnoremap <expr><silent> ss <SID>vsplit_or_wincmdw()
nnoremap sj <C-w>j
nnoremap sk <C-w>k
nnoremap sl <C-w>l
nnoremap sh <C-w>h

" tabpages
"nnoremap <silent> <C-l> :<C-u>silent! tabnext<CR>
"nnoremap <silent> <C-h> :<C-u>silent! tabprev<CR>
nnoremap <silent> <C-l> :<C-u>call <SID>win_tab_switcher('l')<CR>
nnoremap <silent> <C-h> :<C-u>call <SID>win_tab_switcher('h')<CR>
nnoremap t <Nop>
nnoremap <silent> [Space]t :<C-u>tabclose<CR>:<C-u>tabnew<CR>
nnoremap <silent> tt :<C-u>tabnew<CR>
nnoremap <silent> tT :<C-u>tabnew<CR>:<C-u>tabprev<CR>
nnoremap <silent> tc :<C-u>tabclose<CR>
nnoremap <silent> to :<C-u>tabonly<CR>

" Inser matching bracket automatically {{{2
if s:has_plugin("lexima.vim")
  inoremap [ []<LEFT>
  inoremap ( ()<LEFT>
  inoremap " ""<LEFT>
  inoremap ' ''<LEFT>
  inoremap ` ``<LEFT>
endif

" Make cursor-moving useful {{{2
inoremap <C-h> <Backspace>
inoremap <C-d> <Delete>

cnoremap <C-k> <UP>
cnoremap <C-j> <DOWN>
cnoremap <C-l> <RIGHT>
cnoremap <C-h> <LEFT>
cnoremap <C-d> <DELETE>
cnoremap <C-p> <UP>
cnoremap <C-n> <DOWN>
cnoremap <C-f> <RIGHT>
cnoremap <C-b> <LEFT>
cnoremap <C-a> <HOME>
cnoremap <C-e> <END>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-d> <Del>
cnoremap <C-h> <BS>

"nnoremap + <C-a>
"nnoremap - <C-x>

" Nop features {{{2
nnoremap q: <Nop>
nnoremap q/ <Nop>
nnoremap q? <Nop>
nnoremap <Up> <Nop>
nnoremap <Down> <Nop>
nnoremap <Left> <Nop>
nnoremap <Right> <Nop>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>

" Folding (see :h usr_28.txt){{{2
"nnoremap <expr>l foldclosed('.') != -1 ? 'zo' : 'l'
"nnoremap <expr>h col('.') == 1 && foldlevel(line('.')) > 0 ? 'zc' : 'h'
nnoremap <silent>z0 :<C-u>set foldlevel=<C-r>=foldlevel('.')<CR><CR>

" Misc mappings {{{2
cnoreabbrev w!! w !sudo tee > /dev/null %
" CursorLine
" Add a relative number togglj
nnoremap <silent> <Leader>r :<C-u>call <SID>toggle_option('relativenumber')<CR>

" Add a spell check toggle
nnoremap <silent> <Leader>s :<C-u>call <SID>toggle_option('spell')<CR>

" Tabs Increase
nnoremap <silent> ~ :let &tabstop = (&tabstop * 2 > 16) ? 2 : &tabstop * 2<CR>:echo 'tabstop:' &tabstop<CR>

" Toggle top/center/bottom
noremap <expr> zz (winline() == (winheight(0)+1)/ 2) ?  'zt' : (winline() == 1)? 'zb' : 'zz'

" Reset highlight searching
nnoremap <silent> <ESC><ESC> :nohlsearch<CR>

" key map ^,$ to <Space>h,l. Because ^ and $ is difficult to type and damage little finger!!!
noremap [Space]h ^
noremap [Space]l $

" Type 'v', select end of line in visual mode
vnoremap v $h

" Make Y behave like other capitals
nnoremap Y y$

" Do 'zz' after next candidates for search words
nnoremap n nzz
nnoremap N Nzz

" Search word under cursor
nnoremap S *zz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" View file information
nnoremap <C-g> 1<C-g>

" Write only when the buffer has been modified
nnoremap <silent><CR> :<C-u>silent update<CR>

" Goto file under cursor
noremap gf gF
noremap gF gf

" Jump a next blank line
nnoremap <silent>W :<C-u>keepjumps normal! }<CR>
nnoremap <silent>B :<C-u>keepjumps normal! {<CR>

" Save word and exchange it under cursor
nnoremap <silent> ciy ciw<C-r>0<ESC>:let@/=@1<CR>:noh<CR>
nnoremap <silent> cy   ce<C-r>0<ESC>:let@/=@1<CR>:noh<CR>

" Yank the entire file
nnoremap <Leader>y :<C-u>%y<CR>
nnoremap <Leader>Y :<C-u>%y<CR>

" Emacs-kile keybindings in insert mode {{{2
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-h> <BS>
inoremap <C-d> <Del>
inoremap <C-f> <Right>
inoremap <C-b> <Left>
inoremap <C-n> <Up>
inoremap <C-p> <Down>
inoremap <C-m> <CR>

" Misc: {{{1
" Experimental setup and settings that do not belong to any section
" will be described in this section.
"==============================================================================

" EXPERIMENTAL: Experimental code is described here

augroup hilight-idegraphic-space "{{{2
  autocmd!
  "autocmd VimEnter,ColorScheme * highlight IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen
  "autocmd WinEnter * match IdeographicSpace //
  autocmd VimEnter,ColorScheme * call <SID>hl_trailing_spaces()
  autocmd VimEnter,ColorScheme * call <SID>hl_zenkaku_space()
augroup END

function! s:hl_trailing_spaces()
  highlight! link TrailingSpaces Error
  syntax match TrailingSpaces containedin=ALL /\s\+$/
endfunction

function! s:hl_zenkaku_space()
  highlight! link ZenkakuSpace Error
  syntax match ZenkakuSpace containedin=ALL //
endfunction

augroup cursor-highlight-emphasis "{{{2
  autocmd!
  autocmd CursorMoved,CursorMovedI,WinLeave * hi! link CursorLine CursorLine | hi! link CursorColumn CursorColumn
  autocmd CursorHold,CursorHoldI            * hi! link CursorLine Visual     | hi! link CursorColumn Visual
augroup END

augroup vimrc-gui-setting "{{{2
  autocmd!
  autocmd GUIEnter * call s:gui()
augroup END
function! s:gui()
  "colorscheme solarized
  set background=light
  syntax enable

  " Tabpages
  set guitablabel=%{GuiTabLabel()}

  " Change cursor color if IME works.
  if has('multi_byte_ime') || has('xim')
    "highlight Cursor   guibg=NONE guifg=Yellow
    "highlight CursorIM guibg=NONE guifg=Red
    set iminsert=0 imsearch=0
    inoremap <silent> <ESC><ESC>:set iminsert=0<CR>
  endif
  "autocmd VimEnter,ColorScheme * highlight Cursor   guibg=Yellow guifg=Black
  "autocmd VimEnter,ColorScheme * highlight CursorIM guibg=Red    guifg=Black
  autocmd VimEnter,ColorScheme * if &background ==# 'dark'  | highlight Cursor   guibg=Yellow guifg=Black | endif
  autocmd VimEnter,ColorScheme * if &background ==# 'dark'  | highlight CursorIM guibg=Red    guifg=Black | endif
  autocmd VimEnter,ColorScheme * if &background ==# 'light' | highlight Cursor   guibg=Black  guifg=NONE  | endif
  autocmd VimEnter,ColorScheme * if &background ==# 'light' | highlight CursorIM guibg=Red    guifg=Black | endif
  inoremap <silent> <ESC><ESC>:set iminsert=0<CR>

  " Remove all menus.
  try
    source $VIMRUNTIME/delmenu.vim
  catch
  endtry

  " Font
  if s:is_mac
    set guifont=Andale\ Mono:h12
  endif

  " Emphasis
  if has('multi_byte_ime') || has('xim')
    highlight Cursor guibg=NONE guifg=Yellow
    highlight CursorIM guibg=NONE guifg=Red
    set iminsert=0 imsearch=0
    if has('xim') && has('GUI_GTK')
      ""set imactivatekey=s-space
    endif
    inoremap <silent> <ESC><ESC>:set iminsert=0<CR>
  endif
endfunction

augroup help-for-vim "{{{2
  autocmd!
  autocmd FileType help call s:help_for_vim()
augroup END
function! s:help_for_vim()
  only
  nnoremap <buffer> <nowait> q :<C-u>bwipeout<CR>
  "nnoremap <buffer> <nowait> <ESC> :<C-u>bwipeout<CR>
  if &readonly == 0
    setlocal colorcolumn=78
  endif
  setlocal list&
endfunction

augroup vim-startup-nomodified "{{{2
  autocmd!
  autocmd VimEnter * set nomodified
augroup END

augroup auto-make-directory "{{{2
  autocmd!
  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
augroup END

augroup word-count "{{{2
  autocmd!
  autocmd BufWinEnter,InsertLeave,CursorHold * if exists('*WordCount') | call WordCount('char') | endif
augroup END
let s:WordCountStr = ''
let s:WordCountDict = {'word': 2, 'char': 3, 'byte': 4}

augroup auto-mkdir-saving "{{{2
  autocmd!
  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
augroup END

augroup disable-auto-comment "{{{2
  autocmd!
  autocmd FileType * setlocal formatoptions-=ro
augroup END

augroup only-window-help "{{{2
  autocmd!
  "autocmd BufEnter *.jax only
  autocmd Filetype help only
augroup END

augroup set-bash-shebang "{{{2
  autocmd!
  autocmd BufNewFile *.sh 0put =\"#!/bin/bash\" | :2
augroup END

augroup multi-window-toggle-cursor "{{{2
  autocmd!
  autocmd WinEnter * setlocal cursorline
  autocmd WinLeave * setlocal nocursorline nocursorcolumn
augroup END 

" augroup vim-xxd-mode {{{2
if s:env.is_starting && &binary
  augroup vim-xxd-mode
    autocmd!
    autocmd BufReadPost * if &l:binary | setlocal filetype=xxd | endif
  augroup END
endif

augroup vimrc-golang "{{{2
  autocmd!
  autocmd FileType go iabbrev <buffer> err- if err != nil {<C-j>log.Fatal(err)<C-j>}<C-j>
  autocmd FileType go setlocal tabstop=4 shiftwidth=4 noexpandtab copyindent softtabstop=0 nolist

  if exists("$GOPATH")
    let s:gopaths = split($GOPATH, ':')
    for s:gopath in s:gopaths
      "set up Golint    https://github.com/golang/lint
      if isdirectory(s:gopath."/src/github.com/golang/lint/misc/vim")
        exe 'set runtimepath+='.s:gopath.'/src/github.com/golang/lint/misc/vim'
        autocmd BufWritePost,FileWritePost *.go execute 'Lint' | cwindow
        break
      endif
    endfor
  endif
augroup END
""}}}

" Test: {{{1

function! s:neobundled(bundle)
  return s:bundled(a:bundle) && neobundle#tap(a:bundle)
endfunction

" Shougo/neocomplete {{{2
if s:neobundled('neocomplete.vim')
  call neobundle#config({
        \   "lazy" : 1,
        \   "autoload" : {
        \     "insert" : 1,
        \   },
        \   'disabled' : !has('lua'),
        \   'vim_version' : '7.3.885'
        \ })

  function! neobundle#tapped.hooks.on_source(bundle) "{{{
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_camel_case = 1
    let g:neocomplete#enable_underbar_completion = 1

    " Use fuzzy completion.
    let g:neocomplete#enable_fuzzy_completion = 1

    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    " Set auto completion length.
    let g:neocomplete#auto_completion_start_length = 2
    " Set manual completion length.
    let g:neocomplete#manual_completion_start_length = 0
    " Set minimum keyword length.
    let g:neocomplete#min_keyword_length = 3

    " Set neosnippet competion length.
    "call neocomplete#custom#source('neosnippet', 'min_pattern_length', 1)

    let g:neocomplete#disable_auto_select_buffer_name_pattern =
    \ '\[Command Line\]'

    if !exists('g:neocomplete#force_omni_input_patterns')
      let g:neocomplete#force_omni_input_patterns = {}
    endif
    let g:jedi#auto_vim_configuration = 0
    let g:neocomplete#sources#omni#input_patterns = {
    \ 'ruby' : '[^. *\t]\.\w*\|\h\w*::',
    \}
    let g:neocomplete#force_omni_input_patterns = {
    \ 'python': '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
    \}
    " \ 'ruby' : '[^. *\t]\.\|\h\w*::',
    let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scala' : $HOME.'/.vim/myplugin/vim-scala-dict/dict/scala.dict',
    \ }
  endfunction
  "}}}

  " Options
  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#enable_ignore_case = 1
  let g:neocomplete#enable_smart_case = 1
  if !exists('g:neocomplete#keyword_patterns')
      let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns._ = '\h\w*'
  " Commands
  inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
  " Mappings

  " Other {{{
  "inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
  "inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
  "highlight Pmenu      ctermbg=lightcyan ctermfg=black
  "highlight PmenuSel   ctermbg=blue      ctermfg=black
  "highlight PmenuSbari ctermbg=darkgray
  "highlight PmenuThumb ctermbg=lightgray
  "}}}

  call neobundle#untap()
endif

" __END__ {{{1
" Must be written at the last.  see :help 'secure'.
set secure

" vim:fdm=marker expandtab fdc=3 ft=vim ts=2 sw=2 sts=2:
